线程：CPU调度的最小单位

1.javaMain主线程和自己创建线程是平级关系
2.线程是由操作系统进行调度管理，所以是无序的
3.start（）方法启动线程，而run（）方法只是执行任务的部分代码，不会真实启动线程
4.创建并启动线程，会在操作系统中真实的创建并申请系统调度该线程，在申请后由Cpu时间片调度执行（就绪态->运行态）
其中创建线程是比较耗时的


Thread类的静态方法只作用于当前代码范围的线程
Thread.sleep(休眠时间)
Thread.currentThread（）获取当前线程的引用

Thread.yield()表示当前线程由运行态转变为就绪态，也就是说让当前线程放弃当前CPU时间片，重新进入调度队列

实例方法：thread.join():表示阻塞当前线程，而等待引用线程执行完毕

线程不安全的三大特性：

1.原子性：在某个环境下，不可被分割（包括中断，造成结果不正确等）的操作，对于共享变量，基本数据类型赋值操作是原子性的，但是不包括64位的long/double操作。
 经典的非原子性的单条指令：n++/n--/new Object()

2.可见性：工作内存和主内存的一致性。（对于每个线程来说，这个共享变量也是不可见的）

3.有序性：
a.分配对象的内存空间
b.执行对象初始化
c.把对象赋给引用

//🔒：同一个对象的锁，该对象同步作用代码在某个时间点只能有一个线程执行
synchronized（同步互斥）关键字：重点理解锁的是哪个对象 
synchronized静态同步方法：锁定的是当前类对象
synchronized实例方法：锁定当前对象（this）
synchronized（Obj）同步代码块，锁定的是Obj对象

锁定对象的所有同步的地方，都会同步互斥， 


 volatile 关键字：
修饰的共享变量，可以保证可见性，部分保证顺序性
对于有序性来说，具体指禁止指令重排序。（CPU和jvm都有重排序）

用 volatile经常用来保证共享变量的读取操作安全

在每一个线程，自己看自己内部的指令，都是有序的，但是其实JVM、CPU是进行了重排序的。
这些指令在其他线程看来，都是无序

所有在同步队列中，由某个对象锁定的线程，在满足一定的条件（指的是获取到锁的线程退出同步区域，或者是调用wait（）释放锁），所有满足条件的线程都会出队列来竞争这把锁。
synchronized的使用，在某些情况下，比如非常多的线程，执行时间非常短的同步代码，这种时候会不停的让很多线程进出队列，及
竞争锁，这种情况对资源的消耗是比较大。

以上的阻塞方法，对系统及CPU资源的消耗忽略不计。









